
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>THD-PLV2 - Turtlebot3 maze challenges (Quirin Wieser) &#8212; THD-PLV2 - Turtlebot3 Challenge  documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=84ace793992934648b4de8eed757e5a2" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx-book-theme.9d8b4a8b9bb19db25eeaddc40d639ba2.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<div class="col-12 col-md-3 bd-sidebar site-navigation " id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">THD-PLV2 - Turtlebot3 Challenge  documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Durchsuchen Sie die Dokumente ..." aria-label="Durchsuchen Sie die Dokumente ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<!-- This is an invisible pixel that we watch to see if we've scrolled. -->
<div class="sbt-scroll-pixel-helper"></div>
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            <div class="topbar-left">
                
                <label class="nav-toggle-button" for="__navigation">
                    <div class="visually-hidden">Navigation umschalten</div>
                    <i class="fas fa-bars"></i>
                </label>
                
            </div>
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Laden Sie diese Seite herunter"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/quirin.md.txt"><button type="button"
                class="btn btn-secondary topbarbtn" title="Quelldatei herunterladen" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="In PDF drucken"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Vollbildmodus"
        title="Vollbildmodus"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Inhalt
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   1. Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ros2-concepts">
   2. ROS2 Concepts
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#problems">
   3. Problems
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-2-rotation-with-laser-distance-sensor-data">
     Challenge 2: Rotation with laser distance sensor data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-4-robot-getting-stuck-in-a-divider-wall-if-it-sees-a-part-of-the-red-wall-around-it">
     Challenge 4: Robot getting stuck in a divider wall if it sees a part of the red wall around it
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-5-robot-moving-too-close-to-the-walls-in-a-corner-and-knocking-over-the-wall-when-rotating">
     Challenge 5: Robot moving too close to the walls in a corner and knocking over the wall when rotating
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-5-robot-not-rotating-sharp-and-quick-enough-when-having-to-drive-180-degrees-around-a-divider-wall">
     Challenge 5: Robot not rotating sharp and quick enough when having to drive 180 degrees around a divider wall
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-5-robot-not-driving-in-a-straight-line-but-swaying-left-and-right">
     Challenge 5: Robot not driving in a straight line, but swaying left and right
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#relevant-concepts">
   4. Relevant Concepts
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#state-search">
     STATE_SEARCH
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#state-to-wall">
     STATE_TO_WALL
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#state-along-wall">
     STATE_ALONG_WALL
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#approaches-and-solutions">
   5. Approaches and Solutions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Challenge 2: Rotation with laser distance sensor data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     Challenge 4: Robot getting stuck in a divider wall if it sees a part of the red wall around it
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     Challenge 5: Robot moving too close to the walls in a corner and knocking over the wall when rotating
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     Challenge 5: Robot not rotating sharp and quick enough when having to drive 180 degrees around a divider wall
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     Challenge 5: Robot not driving in a straight line, but swaying left and right
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#results-and-takeaways">
   6. Results and Takeaways
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>THD-PLV2 - Turtlebot3 maze challenges (Quirin Wieser)</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Inhalt </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   1. Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ros2-concepts">
   2. ROS2 Concepts
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#problems">
   3. Problems
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-2-rotation-with-laser-distance-sensor-data">
     Challenge 2: Rotation with laser distance sensor data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-4-robot-getting-stuck-in-a-divider-wall-if-it-sees-a-part-of-the-red-wall-around-it">
     Challenge 4: Robot getting stuck in a divider wall if it sees a part of the red wall around it
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-5-robot-moving-too-close-to-the-walls-in-a-corner-and-knocking-over-the-wall-when-rotating">
     Challenge 5: Robot moving too close to the walls in a corner and knocking over the wall when rotating
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-5-robot-not-rotating-sharp-and-quick-enough-when-having-to-drive-180-degrees-around-a-divider-wall">
     Challenge 5: Robot not rotating sharp and quick enough when having to drive 180 degrees around a divider wall
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#challenge-5-robot-not-driving-in-a-straight-line-but-swaying-left-and-right">
     Challenge 5: Robot not driving in a straight line, but swaying left and right
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#relevant-concepts">
   4. Relevant Concepts
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#state-search">
     STATE_SEARCH
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#state-to-wall">
     STATE_TO_WALL
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#state-along-wall">
     STATE_ALONG_WALL
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#approaches-and-solutions">
   5. Approaches and Solutions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Challenge 2: Rotation with laser distance sensor data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     Challenge 4: Robot getting stuck in a divider wall if it sees a part of the red wall around it
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     Challenge 5: Robot moving too close to the walls in a corner and knocking over the wall when rotating
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     Challenge 5: Robot not rotating sharp and quick enough when having to drive 180 degrees around a divider wall
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     Challenge 5: Robot not driving in a straight line, but swaying left and right
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#results-and-takeaways">
   6. Results and Takeaways
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="section" id="thd-plv2-turtlebot3-maze-challenges-quirin-wieser">
<h1>THD-PLV2 - Turtlebot3 maze challenges (Quirin Wieser)<a class="headerlink" href="#thd-plv2-turtlebot3-maze-challenges-quirin-wieser" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This report contains documentation of our activities during the university course PLV2 in the winter semester of 2021. The goal was to program a Turtlebot so that it can navigate simple mazes, in real life as well as in a simulation, without driving against the walls. There were five challenges in total and in later challenges the additional task was for the robot to detect red walls and stop when he is near them. In this report, I will first talk about the theoretical part of the course so that the relevant concepts of how we programmed the robot are clear. What is ROS2, what are nodes and what are topics? After that, I will move on to the practical part of the course. Thomas Bergwinkl and I have worked together on programming the robot and I will first off highlight some of the problems we have faced in the individual challenges, in order to show that programming a robot is not as simple as one might think. After that I will go over the relevant concepts of our final code: I will show all the different states the robot can be in and I will explain what each of these states does based on small code fragments from our actual final code, so you can get a deeper understanding of how exactly programming a robot works. Afterwards, I will showcase the different approaches and solutions that we have taken for the individual challenges to attempt to solve the different problems we faced in them. In the end, I will give my personal opinion on how it is to program a robot with ROS2 and what I have learned from this course.</p>
</div>
<div class="section" id="ros2-concepts">
<h2>2. ROS2 Concepts<a class="headerlink" href="#ros2-concepts" title="Permalink to this headline">¶</a></h2>
<p>ROS stands for “Robot Operating System” and is a set of software libraries and tools for building robot applications. To put it more simply, ROS2 allows you to control the robot and determine how the robot will interact with its environment under certain circumstances. For example, using ROS2 you can get data from sensors that are attached to the robot and with this data, you can then write a python script to program the robot to behave in a specific way for specific data values. To understand how this works you need to understand two important concepts of ROS2: Nodes and Topics. Nodes and Topics work hand in hand and therefore you have to understand both. I will start with ROS2 Nodes: One ROS2 Node should be responsible for a single purpose. This helps you modularise your code. Therefore it is logical to assume that you need multiple Nodes to be able to control every part of the robot. Now, these Nodes can send messages that contain data to other Nodes, allowing the individual parts of the robot to communicate with each other. This works based on the Publisher-Subscriber principle. The basis of the Publisher-Subscriper principle is that messages are being sent from one Node to another. Nodes that send messages to other nodes are Publishers, Nodes that receive data from other Nodes are called subscribers. A node can also be a subscriber and publisher at the same time. A Node can also send messages to itself, if you want to modularise your code within a Node. A good analogy is newspaper subscriptions: People subscribe to certain magazines or newspapers to receive them regularly, which makes them subscribers. The newspaper company that is printing them and sending them out is the publisher. Now, these messages the nodes are publishing do not go directly to the respective subscriber nodes. Instead they go to Topics. Topics are responsible for exchanging messages between Nodes and making sure that the right message goes to the right Node. A Node can also send messages to multiple Nodes on the same Topic. An example: A publisher Node has two Nodes that are subscribed to it. The publisher Node now does not directly send the messages to the two subscriber Nodes, but instead sends it to a Topic which then distributes the message to the two subscriber Nodes. Coming back to the newspaper analogy: The newspaper company does not directly deliver the magazines or newspaper to each individual customer, but instead gives it to a post office, which in this case would be the Topic, and this Post office then distributes the newspapers to all the subscribed customers.</p>
<p><img alt="nodes_topics" src="_images/nodes_topics.svg" /></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>        <span class="bp">self</span><span class="o">.</span><span class="n">cmd_vel_pub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_publisher</span><span class="p">(</span>
                <span class="n">Twist</span><span class="p">,</span>      <span class="c1"># message type</span>
                <span class="s1">&#39;cmd_vel&#39;</span><span class="p">,</span>  <span class="c1"># topic name</span>
                <span class="mi">1</span><span class="p">)</span>          <span class="c1"># history depth</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scan_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_subscription</span><span class="p">(</span>
                <span class="n">LaserScan</span><span class="p">,</span>
                <span class="s1">&#39;scan&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scan_callback</span><span class="p">,</span>  <span class="c1"># function to run upon message arrival</span>
                <span class="n">qos_profile_sensor_data</span><span class="p">)</span>  <span class="c1"># allows packet loss</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">odom_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_subscription</span><span class="p">(</span>
                <span class="n">Odometry</span><span class="p">,</span>
                <span class="s1">&#39;odom&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">odom_callback</span><span class="p">,</span>
                <span class="n">qos_profile_sensor_data</span><span class="p">)</span>
</pre></div>
</div>
<p>In our case in our code, we publish information to the robot, more specifically the wheels, which is the Publisher <code class="docutils literal notranslate"><span class="pre">cmd_vel_pub</span></code>, to be able to move the robot and we subscribe to the laser sensor, and the Odometry data, to get the data we need to tell our robot how to move so that he does not drive into any walls. We have one Node called Tb3 which is a Subscriber as well as a Publisher. It contains two Subscribers named <code class="docutils literal notranslate"><span class="pre">scan_sub</span></code> and <code class="docutils literal notranslate"><span class="pre">odom_sub</span></code> and a Publisher called <code class="docutils literal notranslate"><span class="pre">cmd_vel_pub</span></code>. Each of these Subscribers and Publishers sends or receives a different type of message and also has a Topic associated with them that handles the exchange of these messages regarding this Publisher or Subscriber. The Subscriber <code class="docutils literal notranslate"><span class="pre">scan_sub</span></code> receives messages of the type <code class="docutils literal notranslate"><span class="pre">LaserScan</span></code> from the Topic <code class="docutils literal notranslate"><span class="pre">scan</span></code>, while the Subscriber <code class="docutils literal notranslate"><span class="pre">odom_sub</span></code> receives messages of the type <code class="docutils literal notranslate"><span class="pre">Odometry</span></code> from the Topic <code class="docutils literal notranslate"><span class="pre">odom</span></code> and the Publisher <code class="docutils literal notranslate"><span class="pre">cmd_vel_pub</span></code> send messages of the type <code class="docutils literal notranslate"><span class="pre">Twist</span></code> to the Topic <code class="docutils literal notranslate"><span class="pre">cmd_vel</span></code>. Lastly, the two Subscribers <code class="docutils literal notranslate"><span class="pre">scan_sub</span></code> and <code class="docutils literal notranslate"><span class="pre">odom_sub</span></code> each have a function, also called a callback, associated with them that executes each time a message is received by the respective Subscriber. These functions are being linked to the respective Subscriber through <code class="docutils literal notranslate"><span class="pre">create_subscription</span></code> as seen above. The Subscriber <code class="docutils literal notranslate"><span class="pre">scan_sub</span></code> has the function <code class="docutils literal notranslate"><span class="pre">scan_callback</span></code> associated with it, while the Subscriber <code class="docutils literal notranslate"><span class="pre">odom_sub</span></code> has the function <code class="docutils literal notranslate"><span class="pre">odom_callback</span></code> associated with it.</p>
</div>
<div class="section" id="problems">
<h2>3. Problems<a class="headerlink" href="#problems" title="Permalink to this headline">¶</a></h2>
<div class="section" id="challenge-2-rotation-with-laser-distance-sensor-data">
<h3>Challenge 2: Rotation with laser distance sensor data<a class="headerlink" href="#challenge-2-rotation-with-laser-distance-sensor-data" title="Permalink to this headline">¶</a></h3>
<p>The first problem we faced was in challenge two. The task was to rotate the robot approximately 90 degrees, using only laser distance sensor data. We quickly realised that the robot was rotating at a different angle with each execution, even though we changed nothing in the code. The robot would either turn more than 90 degrees or would turn not enough. It was rare that the robot turned exactly or near 90 degrees and was very dependent on luck.</p>
</div>
<div class="section" id="challenge-4-robot-getting-stuck-in-a-divider-wall-if-it-sees-a-part-of-the-red-wall-around-it">
<h3>Challenge 4: Robot getting stuck in a divider wall if it sees a part of the red wall around it<a class="headerlink" href="#challenge-4-robot-getting-stuck-in-a-divider-wall-if-it-sees-a-part-of-the-red-wall-around-it" title="Permalink to this headline">¶</a></h3>
<p>The next problem we faced was in challenge four. The task was for the robot to recognize a red wall, drive to it and stop in front of it. The problem was, that when the robot saw part of the red wall around a divider wall, the robot would start driving towards the red wall and then approach the divider wall and stop in front of it, essentially getting stuck.</p>
</div>
<div class="section" id="challenge-5-robot-moving-too-close-to-the-walls-in-a-corner-and-knocking-over-the-wall-when-rotating">
<h3>Challenge 5: Robot moving too close to the walls in a corner and knocking over the wall when rotating<a class="headerlink" href="#challenge-5-robot-moving-too-close-to-the-walls-in-a-corner-and-knocking-over-the-wall-when-rotating" title="Permalink to this headline">¶</a></h3>
<p>The next problem we faced was in challenge five, although it is rather a small problem. Sometimes when the robot drove into a specific corner, it would drive too close to the walls, and knock over a wall when rotating. However, this problem was only present in one specific corner and we were not able to reproduce this problem in other corners.</p>
</div>
<div class="section" id="challenge-5-robot-not-rotating-sharp-and-quick-enough-when-having-to-drive-180-degrees-around-a-divider-wall">
<h3>Challenge 5: Robot not rotating sharp and quick enough when having to drive 180 degrees around a divider wall<a class="headerlink" href="#challenge-5-robot-not-rotating-sharp-and-quick-enough-when-having-to-drive-180-degrees-around-a-divider-wall" title="Permalink to this headline">¶</a></h3>
<p>The last major problem we faced, was also in challenge five. The task is the same as in challenge 4, but this time the maze was more complex and intricate, with more corners and divider walls to drive around. The problem in this challenge was, that there were several divider walls in the maze, where the robot had to drive around the divider wall and do a 180-degree turn, then keep driving forward. With our initial code, the robot was not able to rotate fast and sharp enough, but would instead drive forward instead of rotating enough and then recognize the wall in front of it and go back the way it came from, essentially being stuck in an endless loop. At other times, the robot would just rotate endlessly after passing a divider wall, instead of driving forward.</p>
</div>
<div class="section" id="challenge-5-robot-not-driving-in-a-straight-line-but-swaying-left-and-right">
<h3>Challenge 5: Robot not driving in a straight line, but swaying left and right<a class="headerlink" href="#challenge-5-robot-not-driving-in-a-straight-line-but-swaying-left-and-right" title="Permalink to this headline">¶</a></h3>
<p>This is not really a problem but more a minor inconvenience. When driving alongside a wall the robot will not drive in a straight line. Instead, it swerves to the left, away from the wall and then back towards the wall over and over again while driving forward. This is due to the robot trying to both maintain a certain distance to the wall, while also being parallel to it.</p>
</div>
</div>
<div class="section" id="relevant-concepts">
<h2>4. Relevant Concepts<a class="headerlink" href="#relevant-concepts" title="Permalink to this headline">¶</a></h2>
<p>The way our code works and the basic concept of it is quite simple. The robot always searches for and drives alongside the right wall, until it reaches a red wall, at which point the robot stops and the program exits. For that, we have defined three states: <code class="docutils literal notranslate"><span class="pre">STATE_SEARCH</span></code>, <code class="docutils literal notranslate"><span class="pre">STATE_TO_WALL</span></code> and <code class="docutils literal notranslate"><span class="pre">STATE_ALONG_WALL</span></code>. Each of these states contains instructions on what the robot should do, depending on what state it is in and each of these states is in the <code class="docutils literal notranslate"><span class="pre">scan_callback</span></code> function, which means that they will be executed over and over again through the <code class="docutils literal notranslate"><span class="pre">rclpy.spin</span></code> function.</p>
<p><img alt="state diagram" src="_images/state_diagram.svg" /></p>
<div class="section" id="state-search">
<h3>STATE_SEARCH<a class="headerlink" href="#state-search" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">STATE_SEARCH</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_next_to_wall</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_ALONG_WALL</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_TO_WALL</span>
</pre></div>
</div>
<p>This is the state that the robot first starts in when the code is executed. In a nutshell, this state checks if the robot is next to a wall or not. All this state contains is a simple if-else statement that checks if the <code class="docutils literal notranslate"><span class="pre">is_next_to_wall</span></code> variable is <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. The <code class="docutils literal notranslate"><span class="pre">is_next_to_wall</span></code> variable shows if there is a wall to the right side of the robot. The way we have defined that is by implementing a function called <code class="docutils literal notranslate"><span class="pre">next_to_wall</span></code> and assigning the <code class="docutils literal notranslate"><span class="pre">is_next_to_wall</span></code> variable to this function. If the variable <code class="docutils literal notranslate"><span class="pre">is_next_to_wall</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> then the robot goes into the state <code class="docutils literal notranslate"><span class="pre">STATE_ALONG_WALL</span></code>, if it is <code class="docutils literal notranslate"><span class="pre">False</span></code> the robot goes into the state <code class="docutils literal notranslate"><span class="pre">STATE_TO_WALL</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">next_to_wall</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">45</span><span class="p">):</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ranges</span><span class="p">[</span><span class="mi">270</span><span class="o">-</span><span class="n">degree</span><span class="p">:</span><span class="mi">270</span><span class="o">+</span><span class="n">degree</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">DISTANCE_SAFE</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>This method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the robot is close enough near a wall within a 45-degree angle to the right side and <code class="docutils literal notranslate"><span class="pre">False</span></code> if it is not. To make sure that the robot does not collide with any walls, we have defined a variable called <code class="docutils literal notranslate"><span class="pre">DISTANCE_SAFE</span></code> which ensures that the method <code class="docutils literal notranslate"><span class="pre">next_to_wall</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> soon enough that the robot leaves this state before colliding with a wall.</p>
</div>
<div class="section" id="state-to-wall">
<h3>STATE_TO_WALL<a class="headerlink" href="#state-to-wall" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">STATE_TO_WALL</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_distance</span> <span class="o">&lt;</span> <span class="n">DISTANCE_SAFE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">STATE_ALONG_WALL</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vel</span><span class="p">(</span><span class="n">SPEED</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>If the robot is in this state, it means that the robot can not detect a wall at the right side. Similar to the previous state, <code class="docutils literal notranslate"><span class="pre">STATE_SEARCH</span></code>, this state just contains an if-else statement. If the robot is not in front of a wall, it just keeps driving forward. When the robot is a certain distance away from the wall, it stops and goes into the state <code class="docutils literal notranslate"><span class="pre">STATE_ALONG_WALL</span></code>. The <code class="docutils literal notranslate"><span class="pre">DISTANCE_SAFE</span> <span class="pre">*</span> <span class="pre">2</span></code> is the maximum distance the robot is allowed to drive to the wall to prevent the robot from colliding with the wall and also giving it enough space to be able to rotate without colliding with a wall.</p>
</div>
<div class="section" id="state-along-wall">
<h3>STATE_ALONG_WALL<a class="headerlink" href="#state-along-wall" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">STATE_ALONG_WALL</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">find_center</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">intensities</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">center</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="mi">270</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>
</pre></div>
</div>
<p>If the robot is in this state, it means that it found a wall on the right side and it drove towards it. The first thing the robot does is check if the wall that it is next to is the red wall. This is being done through the <code class="docutils literal notranslate"><span class="pre">find_center</span></code> function, which checks if the robot is near the center of a red wall, based on intensities returned from the scan. If the wall the robot is next to has an intensity of 2, meaning that it is red, and if it is in the center of the red wall, with an error range of +- 10 degrees, the robot stops and the program exits.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>            <span class="k">if</span> <span class="n">forward_distance</span> <span class="o">&lt;</span> <span class="n">DISTANCE_CLOSE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SPEED</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vel</span><span class="p">(</span><span class="n">forward_factor</span> <span class="o">*</span> <span class="n">SPEED</span><span class="p">,</span> <span class="n">angle_factor</span> <span class="o">*</span> <span class="n">SPEED</span><span class="p">)</span>
</pre></div>
</div>
<p>If the robot is not next to the red wall, it will just keep driving alongside the wall until it detects a wall in front of it, in which case it will rotate and continue to drive alongside the walls. We have defined the factors <code class="docutils literal notranslate"><span class="pre">forward_factor</span></code> and <code class="docutils literal notranslate"><span class="pre">angle_factor</span></code> so that the robot’s speed is dependent on the distance to the walls. This way we avoid the robot driving too fast towards a wall and not being able to rotate in time, when it has to do a 180-degree rotation around a divider wall for example.</p>
</div>
</div>
<div class="section" id="approaches-and-solutions">
<h2>5. Approaches and Solutions<a class="headerlink" href="#approaches-and-solutions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Challenge 2: Rotation with laser distance sensor data<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Our approach to solving challenge two was to make use of the <code class="docutils literal notranslate"><span class="pre">sleep()</span></code> function and have the robot sleep for a certain amount of time, that we specified by using a calculation to determine how long the robot would take to turn approximately 90 degrees, while it rotates. Once the time we specified was over, the robot would stop rotating and move forward. However, we encountered the problem that the rotation was somewhat random, as mentioned above. After observing a few simulations, we started changing the way we calculate the time, adding factors and using trial and error to determine if we can eliminate, or at least minimize the randomness of the rotation angle. However, despite all this, we could not figure out how to fix the randomness with this approach. So instead of starting over and implementing a different approach, we decided to move on to the next challenge, since it was about using Odometry to rotate the robot, instead of the laser distance sensor, and we figured that this approach would be more accurate and reliable. In hindsight, it was the right choice, as we were correct in that Odometry was a much better method of rotating the robot, and we ended up using Odometry for challenges four and five.</p>
</div>
<div class="section" id="id2">
<h3>Challenge 4: Robot getting stuck in a divider wall if it sees a part of the red wall around it<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Originally we thought that our first approach would not have this problem, since before starting to write the code for this challenge, we thought about this problem beforehand and realised that it will become an issue if we just program the robot to drive towards the red wall if it sees it. Because of this, we did not program our robot to drive to any part of the wall, but to first off find and then drive towards the centre of the red wall. In order to achieve that, we created the <code class="docutils literal notranslate"><span class="pre">find_center</span></code> function, as explained above in <strong>Relevant Concepts</strong>. Our thought was, that when the robot stops in front of the divider wall, it would automatically slowly correct itself with each spin, based on how much of the red wall is visible to him and then make its way slowly around the divider wall. However, since this was not the case, we tried to change and add some factors to make the robot correct itself faster and at a sharper angle and to make the robot move backwards in a curve so it can better adjust, but after several hours eventually decided to give up on this approach and implement the approach explained in <strong>Relevant Concepts</strong>. With the new approach, this particular problem was solved.</p>
</div>
<div class="section" id="id3">
<h3>Challenge 5: Robot moving too close to the walls in a corner and knocking over the wall when rotating<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>When first observing this problem, we were surprised, since we specifically programmed the robot to stop at a safe distance before a wall, which allows the robot to rotate without colliding with a wall. We were even more surprised to see that the robot could navigate the entire maze, including other corners, without colliding with another wall or corner and that the robot would not always collide with that specific corner, but instead, it was seemingly random. We tried tweaking and changing the distance at which the robot stops in front of a wall before rotating, but it did not change anything. The robot would still sometimes collide with the wall in that specific corner and sometimes he would be able to rotate in that corner without colliding with anything. Since it was seemingly random and only appeared in that one corner and we were clueless as to what caused this, we decided to leave it as it is and ignore that problem, since it was not that big of an issue, as it only appeared in that one corner.</p>
</div>
<div class="section" id="id4">
<h3>Challenge 5: Robot not rotating sharp and quick enough when having to drive 180 degrees around a divider wall<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>With our first approach we noticed that the <code class="docutils literal notranslate"><span class="pre">is_next_to_wall</span></code> variable would be <code class="docutils literal notranslate"><span class="pre">False</span></code> at some point when the robot was driving past the divider wall because after doing a 90-degree rotation and driving past the divider wall, it did not realise that it had to do another 90-degree rotation and drive alongside the divider wall. Instead, it was searching for a new wall and found the wall in front of it, which led to it driving backwards and being stuck in an endless loop. After trying to solve the problem by changing some factors like the speed at which the robot moves, the maximum angle at which it can turn and the distance at which it drives alongside the walls, we came to the conclusion that the robot not only had to maintain a consistent distance to the walls but also that it has to always be parallel to it. We originally thought that by maintaining a constant distance at all times, the robot would automatically correct itself every now and then and be parallel to the walls. It worked for corners and normal walls, but not for divider walls. Once we implemented both the consistent distance and the fact that the robot always tries to move parallel to the walls and after changing some more factors and trying to weigh one of the two conditions more than the other it eventually worked and the robot successfully did a 180-degree rotation while driving around the divider wall, without getting stuck or colliding with it. We also tried this in some 1x1 alcoves in the simulation maze and the robot was successfully able to navigate them.</p>
</div>
<div class="section" id="id5">
<h3>Challenge 5: Robot not driving in a straight line, but swaying left and right<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>We tried fixing this problem last after the code was all finished and the robot had successfully gone through the maze several times. We tried to adjust some factors and weigh one of the two conditions, maintaining distance and being parallel, more than the other but it had no effect. Since we discovered this at the end of the course and this does not cause any issues since the spaces in the maze are more than wide enough for the robot to not collide with anything, we quickly gave up on trying to fix it and were satisfied with our code.</p>
</div>
</div>
<div class="section" id="results-and-takeaways">
<h2>6. Results and Takeaways<a class="headerlink" href="#results-and-takeaways" title="Permalink to this headline">¶</a></h2>
<p>The final result of our work is a code that allows the robot to navigate pretty much any simple maze and stop when it reaches a red wall, without colliding with any other walls or getting lost or stuck. One of my biggest takeaways was how complex and difficult programming a robot really is. When you have no prior experience with programming a robot, you would think that it is not that hard to tell the robot what to do. In our first on-campus session, I thought that I would just have to implement some if-else conditions to tell the robot what to do in certain situations. However as it turned out, even seemingly simple tasks like just rotating 90-degrees using laser distance sensor data turned out to be quite a problem and proved a lot more difficult than originally thought. Furthermore, the robot’s behaviour can be unpredictable when certain values or factors are not correct and we often had the case while trying out our code that the robot did something completely different than what we expected it to do, which cost us a lot of time and nerves. To put it in a nutshell my biggest takeaway was that when working with robots and programming robots you should never underestimate the amount of work, time and knowledge that is required to correctly program the robot. Even if it is a seemingly simple task that you want the robot to accomplish you always have to expect that things are not going to go the way you think and you always have to be flexible and come up with new solutions and approaches on the spot, instead of letting it demotivate you or make you give up because eventually, after a lot of trial and error, you will get the right solution, even if it is not what you thought it would be. Apart from that, this was my first experience with robots and how to program them and I have learned quite a lot about it in a short time span. This first experience and gained knowledge will surely help me in future university courses and Artificial Intelligence projects, both in university and in my future workplace.</p>
</div>
</div>


              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      Durch Thomas Bergwinkl, Quirin Wieser<br/>
    
        &copy; Urheberrechte © MIT.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>